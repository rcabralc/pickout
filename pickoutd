#!/usr/bin/env python3
"""
Usage:
    pickoutd [--foreground]

Description:
    This program starts a menu as a daemon.

Options:
    --foreground  Run attached to the terminal (don't daemonize).
    -h, --help    Show this.
"""

from app import App, AsJSONEncoder
from docopt import docopt
from PyQt5.QtCore import QThread, QObject, pyqtSignal

import daemon
import json
import os
import socket
import sys
import time
import traceback


socket_file = '/tmp/pickout.sock'


class PromptCommand:
    def __init__(self, connection, json_output=False, **options):
        self._conn = connection
        self._json_output = json_output
        self._options = options

    def execute(self, app, logger):
        def done(selection):
            result = [entry.value for entry in selection]
            logger.write(f'result: {result!r}\n')
            if self._json_output:
                self._conn.writeline(json.dumps(selection, cls=AsJSONEncoder))
            else:
                for entry in selection:
                    self._conn.writeline(entry.value)
            self._conn.close()
            app.hide()
            app.picked.disconnect(done)

        app.picked.connect(done)
        app.setup(self._fetch_items(logger), **self._options)

    def __repr__(self):
        return f'PROMPT: {self._options!r}'

    @classmethod
    def desserialize(cls, channel, header, conn):
        if header != 'PROMPT':
            return
        options = json.loads(conn.readline())
        return cls(conn, **options)

    def _fetch_items(self, logger):
        t = time.time()
        read = self._conn.readline
        logger.write('reading items\n')
        count = 0
        while True:
            item = read()
            if not item:
                break
            count += 1
            yield item
        logger.write('read %d items in %.3fs\n' % (count, time.time() - t))


class KillCommand:
    def __init__(self, channel):
        self._channel = channel

    def execute(self, app, logger):
        self._channel.quit()

    def __repr__(self):
        return 'KILL'

    @classmethod
    def desserialize(cls, channel, header, conn):
        return cls(channel) if header == 'KILL' else None


class AppWorker(QObject):
    def __init__(self, app, logger=None):
        super(AppWorker, self).__init__()
        self._app = app
        self._logger = logger or nulllogger()

    def execute(self, command):
        command.execute(self._app, self._logger)


class LinewiseConnection:
    def __init__(self, conn, separator=b'\n', encoding='utf-8'):
        self._conn = conn
        self._sep = separator
        self._encoding = encoding
        self._rbuffer = b''

    def readline(self, chunk_size=1024):
        message = self._rbuffer
        sep = self._sep
        lsep = len(sep)
        newline = message.find(sep)

        while not ~newline:
            chunk = self._conn.recv(chunk_size)
            if not chunk:
                raise RuntimeError('socket connection broken')
            message += chunk
            newline = message.find(sep)

        self._rbuffer = message[newline + lsep:]
        return message[:newline].decode(self._encoding)

    def writeline(self, message):
        message = message.encode(self._encoding)
        if not message.endswith(self._sep):
            message = message + self._sep
        self._conn.sendall(message)

    def close(self):
        self._conn.close()
        self._conn = None


class Channel(QObject):
    received = pyqtSignal(object, LinewiseConnection)

    def __init__(self, socket_file, logger):
        super(Channel, self).__init__()
        self._socket_file = socket_file
        self._logger = logger
        self._sock = None

    def open(self):
        if os.path.exists(self._socket_file):
            raise RuntimeError('Already running')

        self._sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self._sock.bind(self._socket_file)
        self._sock.listen(1)
        self._logger.write('listening on ' + self._socket_file + '\n')

        while True:
            conn, _ = self._sock.accept()
            conn = LinewiseConnection(conn)
            header = conn.readline()
            for klass in [KillCommand, PromptCommand]:
                command = klass.desserialize(self, header, conn)
                if command is not None:
                    self._logger.write(f'received: {command!r}\n')
                    self.received.emit(command, conn)
                    break

    def close(self):
        self._logger.close()
        if self._sock:
            self._sock.close()
            self._sock = None
            os.unlink(self._socket_file)

    def quit(self):
        self.close()
        raise SystemExit


def main(args):
    foreground = args['--foreground']
    stderr = sys.stderr if foreground else None
    channel = Channel(socket_file, logger=stderr)
    channel_thread = QThread()
    channel.moveToThread(channel_thread)
    channel_thread.started.connect(channel.open)
    channel_thread.finished.connect(channel.close)

    def excepthook(type, value, trace):
        stderr.write(''.join(traceback.format_exception(type, value, trace)))
        channel.close()
        os.abort()

    sys.excepthook = excepthook

    app = App(logger=stderr)
    with daemon.DaemonContext(detach_process=not foreground, stderr=stderr):
        worker = AppWorker(app, logger=stderr)

        channel.received.connect(worker.execute)
        app.finished.connect(channel_thread.exit)

        channel_thread.start()
        app.exec()


class nulllogger:
    def write(self, *args):
        pass

    def close(self):
        pass


if __name__ == '__main__':
    args = docopt(__doc__)
    main(args)
