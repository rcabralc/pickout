#!/usr/bin/env python3
"""
Usage:
    pickoutd [--foreground] [--keep-stderr]
    pickoutd --kill

Description:
    This program starts a menu as a daemon.

Options:
    --foreground   Run attached to the terminal (don't daemonize).
    --keep-stderr  Don't close the stderr stream in the daemon process.
    -h, --help     Show this.
"""

from app import App, AsJSONEncoder
from docopt import docopt
from PyQt5.QtCore import QThread, QObject, pyqtSignal

import daemon
import json
import os
import socket
import sys


socket_file = '/tmp/pickout.sock'


class PromptCommand:
    def __init__(self, json_output=False, **options):
        self._json_output = json_output
        self._options = options

    def execute(self, app, conn, logger):
        def done(selected):
            result = [entry.value for entry in selected]
            logger.write(f'result: {result!r}\n')
            if self._json_output:
                conn.writeline(json.dumps(selected, cls=AsJSONEncoder))
            else:
                for entry in selected:
                    conn.writeline(entry.value)
            conn.close()
            app.hide()
        try:
            menu = app.setup(self._fetch_items(conn), **self._options)
            menu.accepted.connect(done)
        except:
            conn.close()
            raise

    def __repr__(self):
        return f'PROMPT: {self._options!r}'

    @classmethod
    def desserialize(cls, header, io):
        if header != 'PROMPT':
            return
        options = json.loads(io.readline().strip('\n'))
        return cls(**options)

    def _fetch_items(self, conn):
        while True:
            item = conn.readline().strip('\n')
            if not item:
                break
            yield item


class KillCommand:
    def execute(self, app, conn, logger):
        conn.close()
        app.quit()

    def __repr__(self):
        return 'KILL'

    @classmethod
    def desserialize(cls, header, io):
        return cls() if header == 'KILL' else None


class AppWorker(QObject):
    def __init__(self, app, logger):
        super(AppWorker, self).__init__()
        self._app = app
        self._logger = logger

    def execute(self, command, conn):
        command.execute(self._app, conn, self._logger)


class LinewiseConnection:
    def __init__(self, conn, separator=b'\n', encoding='utf-8'):
        self._conn = conn
        self._sep = separator
        self._encoding = encoding
        self._rbuffer = b''

    def readline(self, strip=False):
        message = self._rbuffer
        newline = message.find(self._sep)

        while not ~newline:
            chunk = self._conn.recv(4096)
            if not chunk:
                raise RuntimeError('socket connection broken')
            message += chunk
            newline = message.find(self._sep)

        newline += 1
        self._rbuffer = message[newline:]
        line = message[:newline]
        if strip:
            line = line.strip(self._sep)
        return line.decode(self._encoding)

    def writeline(self, message):
        message = message.encode(self._encoding)
        if not message.endswith(self._sep):
            message = message + self._sep
        self._conn.sendall(message)

    def close(self):
        self._conn.close()


class Channel(QObject):
    received = pyqtSignal(object, LinewiseConnection)

    def __init__(self, socket_file, logger):
        super(Channel, self).__init__()
        self._socket_file = socket_file
        self._logger = logger
        self._sock = None

    def receive(self):
        while True:
            conn, _ = self._sock.accept()
            conn = LinewiseConnection(conn)
            header = conn.readline(strip=True)
            for klass in [KillCommand, PromptCommand]:
                command = klass.desserialize(header, conn)
                if command is not None:
                    self._logger.write(f'received: {command!r}\n')
                    self.received.emit(command, conn)
                    break

    def __enter__(self):
        if os.path.exists(self._socket_file):
            raise RuntimeError('Socket already in use')
        self._sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self._sock.bind(self._socket_file)
        self._sock.listen(1)
        self._logger.write('listening on ' + self._socket_file + '\n')
        return self

    def __exit__(self, type, value, traceback):
        self._logger.write('exiting\n')
        self._logger.close()
        self._sock.close()
        os.unlink(self._socket_file)
        self._sock = None


def run(logger):
    app = App()

    with Channel(socket_file, logger=logger) as channel:
        channel_thread = QThread()
        channel.moveToThread(channel_thread)
        channel_thread.started.connect(channel.receive)

        worker = AppWorker(app, logger=logger)
        channel.received.connect(worker.execute)

        app.finished.connect(channel_thread.exit)
        channel_thread.start()

        return app.exec_()


def main(args):
    foreground = args['--foreground']
    keep_stderr = args['--keep-stderr']

    if keep_stderr:
        stderr = sys.stderr
    else:
        stderr = None

    with daemon.DaemonContext(detach_process=not foreground,
                              stderr=stderr):
        run(make_logger(stderr))


class nulllogger:
    def write(self, *args):
        pass

    def close(self):
        pass


def make_logger(stream=None):
    if stream:
        return stream
    return nulllogger()


if __name__ == '__main__':
    args = docopt(__doc__)
    main(args)
