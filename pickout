#!/usr/bin/env python3
"""Pickout.

Usage:
    pickout [--accept-input]
            [--app-name=<name>]
            [--completion-sep=<sep>]
            [--daemonize|--loop]
            [--debug]
            [--history-key=<key>]
            [--input=<input>]
            [--json-output]
            [--limit=<limit>]
            [--no-center]
            [--title=<title>]
            [--word-delimiters=<delimiters>]
    pickout --kill-daemon

Options:
    --accept-input
        Allow any text typed in the search input to be accepted through
        Ctrl-Enter.

    --app-name <name>
        [default: pickout]

        In X11 this will be added to the WM_CLASS property of the main window.

    --completion-sep <sep>
        Separator used for completion.  Without this, completion works by
        completing longest common match.  This can be used to complete only
        directories in a list of files, for instance: use '/' (or OS path
        separator) for this.

    -d, --daemonize
        Create a daemon process if none exists, bring its window to the top and
        connect to it.

        When the daemon outputs an option, that option is written to the
        standard output of this process, which then exits, leaving the daemon
        running in background.

        Keeping a daemon in background can improve further startups.

    --debug
        Print additional information to STDERR.

    --history-key <key>
        A key which must be unique to store/retrieve history.  Any string can
        be used.  History is enabled only if this option is provided and is not
        empty.

        For instance, if listing all files under a specific directory, use that
        directory as the key.  Next time this program is used for this
        directory, it'll remember the previous input, allowing the user to
        reuse it.

    -i <input>, --input <input>
        Use <input> as a initial value.

    --json-output
        Return the selection as a JSON array.

    --kill-daemon
        Kill the daemon if it exists, and exit immediately.

    -l <limit>, --limit <limit>
        Limit output up to <limit> results.  Use a negative number to not limit
        output.

    --loop
        Don't quit until SIGTERM is received or the menu window is closed, and
        wait new items on STDIN after printing a selection to STDOUT, in a
        loop.

        Items are read from STDIN until a blank line is read (which is
        ignored).  A selection is written to STDOUT, followed by a blank line.
        If no selection is made, a single blank line is printed.

    --no-center
        Do not move window to the center of the screen.

    --title <title>
        Set the window title to <title>.

    --word-delimiters <delimiters>
        Delimiters used for words.

    -h, --help
        Show this.

Key bindings:

    Enter
        Accept the selected item, that is, print it to STDOUT and exit.

    Ctrl+Enter
        Accept the input, that is, print it to STDOUT and exit.

    Esc or Ctrl+Space
        Quit, without printing anything.

    Tab
        Complete.

    CTRL+J
        Select next entry.

    CTRL+K
        Select previous entry.

    Ctrl+N
        Get next history entry and use it as the input.

    Ctrl+P
        Get previous history entry and use it as the input.

    Ctrl+Y
        Copy selected entry to the input box.
"""

from docopt import docopt

import json
import os
import socket
import sys
import subprocess
import time


daemon_socket_file = '/tmp/pickout.sock'
basedir = os.path.dirname(__file__)


def main(args):
    if args['--kill-daemon']:
        return kill_daemon()

    limit = args['--limit']
    limit = int(limit) if limit and int(limit) >= 0 else None
    json_output = args['--json-output']

    fn = runner(daemonize=args['--daemonize'],
                loop=args['--loop'],
                logger=sys.stderr if args['--debug'] else None)

    return fn(
        app_name=args['--app-name'],
        input=args['--input'],
        limit=limit,
        center=not args['--no-center'],
        sep=args['--completion-sep'],
        delimiters=list((args['--word-delimiters'] or '')),
        history_key=args['--history-key'],
        accept_input=args['--accept-input'],
        json_output=json_output,
        title=args['--title']
    )


def non_daemonized_runner(logger=None, loop=False):
    from app import run, read_io

    def fn(**kw):
        entries = read_io(sys.stdin)
        return run(entries, logger=logger, loop=loop, **kw)

    return fn


def spawn_daemon(max_attempts=10):
    class Attempt:
        def get_socket(self):
            if not os.path.exists(daemon_socket_file):
                time.sleep(0.5)
                return
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(daemon_socket_file)
            return sock

    if not os.path.exists(daemon_socket_file):
        exe = sys.executable
        subprocess.call([exe, os.path.join(basedir, 'pickoutd')])

    for i in range(max_attempts):
        yield Attempt()


def get_daemon_socket():
    for attempt in spawn_daemon():
        sock = attempt.get_socket()
        if sock:
            return sock
    raise RuntimeError("could not connect to daemon")


def runner(daemonize=False, logger=None, loop=False):
    if not daemonize:
        return non_daemonized_runner(logger=logger, loop=loop)

    sock = get_daemon_socket()

    def fn(**kw):
        send = sock.sendall
        send(b'PROMPT\n')
        send((json.dumps(kw) + '\n').encode('utf-8'))
        chunk_size = 1024
        read = sys.stdin.buffer.read
        chunk = read(chunk_size)
        while chunk:
            send(chunk)
            chunk = read(chunk_size)
        send(b'\n\n')
        result = sock.recv(4096)
        if result:
            sys.stdout.write(result.decode('utf-8'))
        sys.stdout.close()
        sock.close()
    return fn


def kill_daemon():
    if not os.path.exists(daemon_socket_file):
        return

    try:
        sock = get_daemon_socket()
    except ConnectionRefusedError:
        if os.path.exists(daemon_socket_file):
            os.unlink(daemon_socket_file)
    else:
        sock.sendall(b'KILL\n')
        sock.close()


if __name__ == '__main__':
    sys.exit(main(docopt(__doc__)))
