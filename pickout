#!/usr/bin/env python3
"""Pickout.

Usage:
    pickout [options]

Options:
    --accept-input
        Allow any text typed in the search input to be accepted through
        Ctrl-Enter.

    --completion-sep SEP
        Separator used for completion.  Without this, completion works by
        completing longest common match.  This can be used to complete only
        directories in a list of files, for instance: use '/' (or OS path
        separator) for this.

    -d, --daemonize
        Create a daemon process if none exists, bring its window to the top and
        connect to it.

        When the daemon outputs an option, that option is written to the
        standard output of this process, which then exits, leaving the daemon
        running in background.

        Keeping a daemon in background can improve further startups.

    --debug
        Print additional information to STDERR.

    --history-key KEY
        A key which must be unique to store/retrieve history.  Any string can
        be used.  History is enabled only if this option is provided and is not
        empty.

        For instance, if listing all files under a specific directory, use that
        directory as the key.  Next time this program is used for this
        directory, it'll remember the previous input, allowing the user to
        reuse it.

    -i, --input INPUT
        Use INPUT as a initial value.

    --keep-empty-lines
        Don't filter out empty lines from input.

    --kill-daemon
        Kill the daemon if it exists, and exit immediately.  All other options
        are ignored.

    -l, --limit LIMIT
        Limit output up to LIMIT results.  Use a negative number to not limit
        output.

    --title TITLE
        Set the window title to TITLE.

    --word-delimiters DELIMITERS
        Delimiters used for words.

    -h, --help
        Show this.

Key bindings:

    Enter
        Accept the selected item, that is, print it to STDOUT and exit.

    Ctrl+Enter
        Accept the input, that is, print it to STDOUT and exit.

    Esc or Ctrl+Space
        Quit, without printing anything.

    Tab
        Complete.

    CTRL+J
        Select next entry.

    CTRL+K
        Select previous entry.

    Ctrl+N
        Get next history entry and use it as the input.

    Ctrl+P
        Get previous history entry and use it as the input.

    Ctrl+Y
        Copy selected entry to the input box.
"""

from docopt import docopt

import json
import os
import socket
import sys
import subprocess
import time


daemon_socket_file = '/tmp/pickout.sock'
basedir = os.path.dirname(__file__)


def main(args):
    if args['--kill-daemon']:
        return kill_daemon()

    limit = args['--limit']
    limit = int(limit) if limit and int(limit) >= 0 else None

    fn = runner(daemonize=args['--daemonize'])

    return fn(
        (line.strip() for line in sys.stdin.readlines()),
        input=args['--input'],
        limit=limit,
        sep=args['--completion-sep'],
        delimiters=list((args['--word-delimiters'] or '')),
        history_key=args['--history-key'],
        accept_input=args['--accept-input'],
        keep_empty_items=args['--keep-empty-lines'],
        title=args['--title'],
        debug=args['--debug']
    )


def non_daemonized_runner():
    from app import run
    return run


def spawn_daemon(max_attempts=10):
    class Attempt:
        def get_socket(self):
            if not os.path.exists(daemon_socket_file):
                time.sleep(0.5)
                return
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(daemon_socket_file)
            return sock

    if not os.path.exists(daemon_socket_file):
        exe = sys.executable
        subprocess.call([exe, os.path.join(basedir, 'pickoutd')])

    for i in range(max_attempts):
        yield Attempt()


def get_daemon_socket():
    for attempt in spawn_daemon():
        sock = attempt.get_socket()
        if sock:
            return sock
    raise RuntimeError("could not connect to daemon")


def runner(daemonize=False):
    if not daemonize:
        return non_daemonized_runner()

    sock = get_daemon_socket()

    def fn(items, **kw):
        sock.sendall(b'PROMPT\n')
        sock.sendall((json.dumps(kw) + '\n').encode('utf-8'))
        for item in items:
            if not item.endswith('\n'):
                item = item + '\n'
            sock.sendall(item.encode('utf-8'))
        sock.sendall(b'\n')
        result = sock.recv(4096)
        if result:
            sys.stdout.write(result.decode('utf-8'))
        sys.stdout.close()
        sock.close()
        return 0
    return fn


def kill_daemon():
    if not os.path.exists(daemon_socket_file):
        return

    try:
        sock = get_daemon_socket()
    except ConnectionRefusedError:
        if os.path.exists(daemon_socket_file):
            os.unlink(daemon_socket_file)
    else:
        sock.sendall(b'KILL\n')
        sock.close()


if __name__ == '__main__':
    sys.exit(main(docopt(__doc__)))
