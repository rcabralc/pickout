#!/usr/bin/python
"""Pickout a file from a directory using pickout and rg.

Usage:
    pickout-file [--accept-input]
                 [--app-name=<name>]
                 [--completion-sep=<sep>]
                 [--hidden]
                 [--home=<input>]
                 [--glob=<pattern>...]
                 [--path=<path>]
                 [--no-center]
                 [--no-ignore]
                 [--title=<title>]
                 [<dir>...]

Arguments:
    <dir>
        The directories in which the files are recursively listed for picking.
        By default, only the current working directory.

Options:
    --accept-input
    --app-name <name>
    --completion-sep <sep>
    --home <input>
    --no-center
    --title <title>
        Options passed down to pickout.

        If no --title is given, "Select file from <dir>…" is set.

    --hidden
    -g <pattern>..., --glob <pattern>...
    --no-ignore
        Options passed down to rg(1).

    --path <path>
        A reference file or directory that will be used to generate pickout's
        initial --input and leverage ignored paths given through --glob option.

        If --path is an absolute path, it will be transformed into a relative
        path relative from <dir>.

        If any exclusion glob (see --glob and rg(1) --glob option) would
        exclude the directory referenced by --path, the glob is ignored.

        If --path is under a hidden tree and hidden files are going to be
        ignored, an additional search path is added to rg such that the path
        is included in the list along with its closest ancestor hidden tree.

        If --path is inside a Git repository but would be ignored by .gitignore
        rules, and --no-ignore was not used (that is, rg is set to ignore Git-
        ignored files), the root of the repository is used as pickout --input
        instead.

    -h, --help
        Show this.

Description:
    pickout-file will use rg(1) with --files option to collect files for
    pickout.

    The directory used to start searching for files is <dir>.  It's possible
    control which directories or files to include or exclude from search by
    using multiple --glob options (see rg(1) for details).

    A directory can be picked from the menu if entered explicitly, which is
    allowed if --accept-input is used, or selected, starting a new search
    using the picked directory as the starting point.

    Note that `..` can be entered to access the parent directory on unixes.
"""

from docopt import docopt
from shutil import which
from subprocess import DEVNULL, PIPE, Popen, run

import io
import json
import os
import pathlib
import pathspec
import sys


rg_default_args = [which('rg'), '--files', '--follow']


def main(args):
	original_globs = args['--glob']
	path = args['--path'] or os.curdir
	hidden = args['--hidden']
	no_ignore = args['--no-ignore']
	roots = list(set(os.path.abspath(d) for d in (args['<dir>'] or [os.curdir])))
	home = args['--home']
	initial_root = root = os.path.commonpath(roots)
	paths = [os.path.relpath(d, root) for d in roots if d != root]
	path = os.path.relpath(path, root)

	if os.path.isfile(path):
		path = os.path.dirname(path)

	# Prevent --path from not matching anything by skipping any exclusion glob
	# that would exclude it.
	globs = [g for g in original_globs if not glob_excludes(g, path)]

	if path == os.curdir:
		path = ''
	else:
		# Include a search path for --path if it is inside a hidden tree and
		# hidden files are not going to be listed.
		segments = path.split(os.path.sep)
		in_hidden_tree = [s for s in segments if s.startswith('.')]
		if not hidden and in_hidden_tree:
			found_last_hidden = False
			search_segments = []
			for segment in reversed(segments):
				if not found_last_hidden and segment.startswith('.'):
					found_last_hidden = True
				if found_last_hidden:
					search_segments.insert(0, segment)
			paths.append(os.path.join(*search_segments))

	paths = list(set(paths))
	if path:
		is_git = run(
			['git', '-C', path, 'rev-parse', '--show-toplevel'],
			capture_output=True
		)

		if not no_ignore and is_git.returncode == 0:
			git_root = is_git.stdout.decode('utf-8').rstrip()
			# If path would be excluded by Git, use the root of the repository as
			# path.
			rel_path = os.path.relpath(path, git_root)
			check_ignore = run(
				['git', '-C', git_root, 'check-ignore', rel_path],
				capture_output=True
			)
			if check_ignore.returncode == 0:
				path = os.path.relpath(git_root, root)

		path += os.path.sep

	pickout = Popen(
		pickout_cmd_args(args),
		bufsize=0,
		stdin=PIPE,
		stdout=PIPE,
		stderr=sys.stderr
	)

	with pickout:
		while True:
			sed = Popen(
				['sed', r's/\.\///'],
				stdin=PIPE,
				stdout=PIPE,
				stderr=PIPE
			)
			with sed:
				with grep(root, paths, globs, hidden, no_ignore) as rg:
					files, _ = sed.communicate(rg.stdout.read())

					add_pardir = root != initial_root
					choice = choose(pickout, files, args, root, home, path, add_pardir)

					if not choice:
						break

					choice_value = choice['value']
					path = os.path.normpath(os.path.join(root, choice_value.rstrip('\n')))

					if not os.path.isdir(path):
						print(path)
						break

					if choice['index'] != -1:
						root = initial_root
						path = os.path.relpath(path, root) + os.path.sep
						if (path == os.curdir + os.path.sep or
								path == os.pardir + os.path.sep):
							path = ''
					else:
						root = path
						path = ''

					globs = original_globs
					paths = []
	pickout.terminate()


def glob_excludes(glob, path):
	if not glob.startswith('!'):
		return False

	spec = pathspec.PathSpec.from_lines('gitwildmatch', [glob[1:]])
	return spec.match_file(path)


def pickout_cmd_args(args):
	this_path = pathlib.Path(__file__).resolve()
	script_path = this_path.parent.joinpath('__init__.py')
	cmd_args = [sys.executable, script_path, '--loop', '--json-output']
	if args['--no-center']:
		cmd_args.append('--no-center')
	if value := args['--title']:
		cmd_args.extend(['--title', value])
	if value := args['--app-name']:
		cmd_args.extend(['--app-name', value])
	return cmd_args


def grep(root, paths, globs, hidden=False, no_ignore=False):
	args = [which('rg'), '--files', '--follow']
	if hidden:
		args.append('--hidden')
	if no_ignore:
		args.append('--no-ignore')
	for glob in globs:
		args.extend(['--glob', glob])
	args.extend(['.', *paths])
	return Popen(args, cwd=root, stderr=DEVNULL, stdout=PIPE)


def choose(pickout, files, args, root, home=None, input='', add_pardir=True):
	title = args['--title'] or f'Select file from {root}…'
	key = f'file://{root}'
	loop_args = dict(
		history_key=key,
		input=input,
		title=title,
		word_delimiters=os.path.sep
	)
	loop_args['accept_input'] = args['--accept-input']
	if value := args['--completion-sep']:
		loop_args['completion_sep'] = value
	if home:
		loop_args['home'] = home

	pickout.stdin.write(json.dumps(loop_args).encode('utf-8') + b'\n')

	if add_pardir:
		# If the parent directory is not root, offer the option to access it.
		if len(root.split(os.path.sep)) > 2:
			pickout.stdin.write((os.pardir + '\n').encode('utf-8'))

	pickout.stdin.write(files + b'\n')

	choices = json.loads(pickout.stdout.readline() or '[]')
	return choices[-1] if choices else None


if __name__ == '__main__':
	sys.exit(main(docopt(__doc__)))
