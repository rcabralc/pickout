#!/usr/bin/python
"""Pickout a file from a directory using pickout and rg.

Usage:
    pickout-file [--accept-input]
                 [--app-name=<name>]
                 [--completion-sep=<sep>]
                 [--hidden]
                 [--home=<input>]
                 [--glob=<pattern>]...
                 [--path=<path>]
                 [--no-center]
                 [--no-ignore]
                 [--title=<title>]
                 [<dir>]

Arguments:
    <dir>
        The directory in which the files are recursively listed for picking.
        By default, the current working directory.

Options:
    --accept-input
    --app-name <name>
    --completion-sep <sep>
    --home <input>
    --no-center
    --title <title>
        Options passed down to pickout.

        If no --title is given, "Select file from <dir>" is set.

    --hidden
    -g <pattern>, --glob <pattern> ...
    --no-ignore
        Options passed down to rg(1).

    --path <path>
        A reference file or directory that will be used to generate pickout's
        initial --input and leverage ignored paths given through --glob option.

        If --path is an absolute path, it will be transformed into a relative
        path relative from <dir>.

        If any exclusion glob (see --glob and rg(1) --glob option) would
        exclude the directory referenced by --path, the glob is ignored.

        If --path is under a hidden tree and hidden files are going to be
        ignored, an additional search path is added to rg such that the path
        is included in the list along with its closest ancestor hidden tree.

        If --path is inside a Git repository but would be ignored by .gitignore
        rules, and --no-ignore was not used (that is, rg is set to ignore Git-
        ignored files), the root of the repository is used as pickout --input
        instead.

    -h, --help
        Show this.

Description:
    pickout-file will use rg(1) with --files option to collect files for
    pickout.

    The directory used to start searching for files is <dir>.  It's possible
    control which directories or files to include or exclude from search by
    using multiple --glob options (see rg(1) for details).

    A directory can be picked from the menu if entered explicitly, which is
    allowed if --accept-input is used, or selected, starting a new search
    using the picked directory as the starting point.

    Note that `..` can be entered to access the parent directory on unixes.
"""

from docopt import docopt
from shutil import which
from subprocess import DEVNULL, PIPE, Popen, run

import io
import json
import os
import pathspec
import sys


rg_default_args = [which('rg'), '--files', '--follow']


def main(args):
    original_globs = args['--glob']
    path = args['--path'] or os.curdir
    hidden = args['--hidden']
    no_ignore = args['--no-ignore']
    root = os.path.abspath(args['<dir>'] or os.curdir)
    home = args['--home']
    initial_root = root = '/' + root.lstrip(os.path.sep)
    path = os.path.relpath(path, root)

    if os.path.isfile(path):
        path = os.path.dirname(path)

    # Prevent --path from not matching anything by skipping any exclusion glob
    # that would exclude it.
    globs = [g for g in original_globs if not glob_excludes(g, path)]

    paths = []
    if path == os.curdir:
        path = ''
    else:
        # Include a search path for --path if it is inside a hidden tree and
        # hidden files are not going to be listed.
        segments = path.split(os.path.sep)
        in_hidden_tree = [s for s in segments if s.startswith('.')]
        if not hidden and in_hidden_tree:
            found_last_hidden = False
            search_segments = []
            for segment in reversed(segments):
                if not found_last_hidden and segment.startswith('.'):
                    found_last_hidden = True
                if found_last_hidden:
                    search_segments.insert(0, segment)
            paths.append(os.path.join(*search_segments))

    is_git = path and run(
        ['git', '-C', path, 'rev-parse', '--show-toplevel'],
        capture_output=True
    )

    if not no_ignore and is_git.returncode == 0:
        git_root = is_git.stdout.decode('utf-8').rstrip()
        # If path would be excluded by Git, use the root of the repository as
        # path.
        rel_path = os.path.relpath(path, git_root)
        check_ignore = run(
            ['git', '-C', git_root, 'check-ignore', rel_path],
            capture_output=True
        )
        if check_ignore.returncode == 0:
            path = os.path.relpath(git_root, root)

    if path:
        path += os.path.sep

    pickout = Popen(
        pickout_cmd_args(args),
        bufsize=0,
        stdin=PIPE,
        stdout=PIPE,
        stderr=sys.stderr
    )

    with pickout:
        while True:
            sed = Popen(
                ['sed', 's/\.\///'],
                stdin=PIPE,
                stdout=PIPE,
                stderr=PIPE
            )
            with sed:
                with grep(root, paths, globs, hidden, no_ignore) as rg:
                    files, _ = sed.communicate(rg.stdout.read())
                    results = set(iter(io.BytesIO(files).readline, b''))

                    add_pardir = root != initial_root
                    choice = choose(pickout, files, args, root, home, path, add_pardir)

                    if not choice.rstrip('\n'):
                        break

                    path = os.path.normpath(os.path.join(root, choice.rstrip('\n')))

                    if not os.path.isdir(path):
                        print(path)
                        break

                    if choice.encode('utf-8') in results:
                        root = initial_root
                        path = os.path.relpath(path, root) + os.path.sep
                        if (path == os.curdir + os.path.sep or
                                path == os.pardir + os.path.sep):
                            path = ''
                    else:
                        root = path
                        path = ''

                    globs = original_globs
                    paths = []
    pickout.terminate()


def glob_excludes(glob, path):
    if not glob.startswith('!'):
        return False

    spec = pathspec.PathSpec.from_lines('gitwildmatch', [glob])
    return spec.match_file(path)


def pickout_cmd_args(args):
    cmd_args = ['pickout', '--loop']
    if value := args['--no-center']:
        cmd_args.append('--no-center')
    if value := args['--app-name']:
        cmd_args.extend(['--app-name', value])
    return cmd_args


def grep(root, paths, globs, hidden=False, no_ignore=False):
    args = [which('rg'), '--files', '--follow']
    if hidden:
        args.append('--hidden')
    if no_ignore:
        args.append('--no-ignore')
    for glob in globs:
        args.extend(['--glob', glob])
    args.extend(['.', *paths])
    return Popen(args, cwd=root, stderr=DEVNULL, stdout=PIPE)


def choose(pickout, files, args, root, home=None, input='', add_pardir=True):
    title = args['--title'] or f'Select file from {root}'
    key = f'file://{root}'
    loop_args = dict(
        history_key=key,
        input=input,
        title=title,
        word_delimiters=os.path.sep
    )
    loop_args['accept_input'] = args['--accept-input']
    if value := args['--completion-sep']:
        loop_args['completion_sep'] = value
    if home:
        loop_args['home'] = home

    pickout.stdin.write(json.dumps(loop_args).encode('utf-8') + b'\n')

    if add_pardir:
        # If the parent directory is not root, offer the option to access it.
        if len(root.split(os.path.sep)) > 2:
            pickout.stdin.write((os.pardir + '\n').encode('utf-8'))

    pickout.stdin.write(files + b'\n')

    choice = b''
    for line in pickout.stdout:
        if (line := line.rstrip(b'\n')):
            choice = line + b'\n'
            continue
        break

    return choice.decode('utf-8')


if __name__ == '__main__':
    sys.exit(main(docopt(__doc__)))
